import java.util.*;

class Dijkstra {
 
    public static void dijkstra(Map<Integer, List<Edge>> graph, int start) {
        int n = graph.size();

        // Distance array, initialized to infinity
        int[] dist = new int[n];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[start] = 0;

        // Min-heap priority queue (stores [distance, node])
        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));
        pq.offer(new int[]{0, start});

        while (!pq.isEmpty()) {
            int[] current = pq.poll();
            int currDist = current[0];
            int node = current[1];

            // If we've already found a shorter path, skip
            if (currDist > dist[node]) continue;

            // Check all neighbors
            for (Edge edge : graph.getOrDefault(node, Collections.emptyList())) {
                int newDist = currDist + edge.weight;
                if (newDist < dist[edge.dest]) {
                    dist[edge.dest] = newDist;
                    pq.offer(new int[]{newDist, edge.dest});
                }
            }
        }

        // Print shortest distances
        System.out.println("Shortest distances from node " + start + ":");
        for (int i = 0; i < n; i++) {
            System.out.println("To " + i + " -> " + (dist[i] == Integer.MAX_VALUE ? "INF" : dist[i]));
        }
    }

    public static void main(String[] args) {
        // Graph represented as adjacency list
        Map<Integer, List<Edge>> graph = new HashMap<>();
        graph.put(0, Arrays.asList(new Edge(1, 4), new Edge(2, 1)));
        graph.put(1, Arrays.asList(new Edge(3, 1)));
        graph.put(2, Arrays.asList(new Edge(1, 2), new Edge(3, 5)));
        graph.put(3, Arrays.asList());

        dijkstra(graph, 0);
    }
}
